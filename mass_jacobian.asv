function [m11, m12, m21, m22, error] = mass_jacobian(x,y,debug)
% mass_jacobian see pdf
% given xy coordinates, it returns the mass jacobian
% if debug true, it also prints it
% error = true means an error somewhere
[a1,a2,p1,p2, error] = inverse_kin(x,y, false);

L =0.127;
if not(error)
g11 = sin(a1-a2)/sin(p1-p2);
g12 = sin(p2-a2)/sin(p1-p2);
g21 = sin(a1-p1)/sin(p1-p2);
g22 = sin(p1-p2)/sin(p1-p2);

%LINK 1
l1_1 = -L/2 *sin(a1);
l2_1 = L/2 *cos(a1);
l3_1 = 1;
l1_2 = 0;
l2_2 = 0;
l3_2 = 0;

% LINK 2
l4_1= -L *sin(a1) - L/2 *sin(p1) * g11;
l5_1= L *cos(a1) + L/2 *cos(p1) * g11;
l6_1 = g11;

l4_2 = -L *sin(a2) - L *sin(p2) * g21 + L/2 *sin(p1) * g12;
l5_2 =  L *cos(a2) + L *cos(p2) * g21 - L/2 *cos(p1) * g12;
l6_2 = g12;


% LINK 3
l4_1= -L *sin(a1) - L/2 *sin(p1) * g11;
l5_1= L *cos(a1) + L/2 *cos(p1) * g11;
l6_1 = g11;

l4_2 = -L *sin(a2) - L *sin(p2) * g21 + L/2 *sin(p1) * g12;
l5_2 =  L *cos(a2) + L *cos(p2) * g21 - L/2 *cos(p1) * g12;
l6_2 = g12;


% LINK 4

l7_1 = -L *sin(a1) - L *sin(p1) * g11 + L/2 *sin(p2) * g21;
l8_1 = L- *sin(a1) - L *sin(p1) * g11 + L/2 *sin(p2) * g21;











else 
    m11 = NaN;
    m12 = NaN;
    m21 = NaN;
    m22 = NaN;
    error = 1;
    
    


end
end

